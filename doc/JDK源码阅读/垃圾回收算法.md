## 判定可回收状态算法
* 可达性分析
  从GC Roots开始向下搜索，当GC Roots 到达不了某一对象时，则这个对象可回收
* 引用计数器
  当计数器为0 则可回收
## 在Java语言中，可作为GC Roots的对象包括下面这些：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象

2. 方法区中的类静态属性引用的对象

3. 方法区中的常量引用的对象

4. 本地方法栈（Native方法）引用的对象 
## 什么时候回收
关于如何回收的问题，根搜索算法中不可达的对象，并不是立刻就会被回收，而是会经过一次标记：<br/>
如果对象没有覆盖finalize()方法，或者finalize()方法已经被调用，虚拟机会判定这个对象没必要执行finalize()，在这一次标记中该对象不会被回收。<br/>
如果这个对象被标记为有必要执行finalize()方法时，它会被放置在一个名为F-Queue的队列中，稍后由虚拟机进行垃圾回收。<br/>
但是这个对象还有最后一次逃脱的机会，当在F-Queue时，虚拟机会对F-Queue中的对象作小规模的标记，如果发现此时某个对象又可达了，就会逃过GC的命运。<br/>
## 回收算法
*  标记-清除算法（Mark-Sweep） 先标记那些那内存是可清除的，然后回收，会遗留大量内存碎片
* 复制算法（Copying）将正在使用的内存全部移到另一端，然后进行回收。<br/>
广泛应用于新生代的垃圾回收，由于新生代的对象有百分之98左右都是要被回收的，因此新生代的内存会被分为一块Eden空间和两块Survivor空间，比例为8：1：1。
第一次YGC只回收eden区域，回收后大多数（百分之九十八左右）的对象会被回收，活着的对象通过复制算法进入Survivor0（后续用S0和S1代替）。再次YGC后，eden+S0中活着的对象进入S1。再次YGC，eden+S1中活着的对象进入到S0。依次循环
*  标记-整理（Mark-Compact）
标记-整理算法分为标记、整理、清除三步，第一步也是标记出可回收的对象，然后让存活的对象移到一边，然后直接清理掉边界外的垃圾。
## 何时触发YoungGC或FullGC
* YoungGC的触发时常在发生，当新生代的Eden区满了之后就会触发YoungGC
* FullGC在多个情况下都会被触发：<br/>
	1. 发生Young GC之前进行检查，如果“老年代可用的连续内存空间" < " 新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间，此时会触发FullGC<br/>
	2. 当老年代没有足够空间存放对象时，会触发一次FullGC<br/>
	3. 如果元空间区域的内存达到了所设定的阈值-XX:MetaspaceSize=，也会触发FullGC。


